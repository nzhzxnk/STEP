### Week2 Homewook1の検討

## HashTable 各バージョンの概要と目的

  * **HashTable\_1 (Normal)**: サンプルコードに `delete` 関数を追加したバージョン。基本的な機能を持つ比較基準として使用。
  * **HashTable\_2 (Change hash function)**: HashTable\_1 に加えて `calculate_hash` 関数を改善したバージョン。
  * **HashTable\_3 (Rehash)**: HashTable\_2 の機能に加え、負荷に応じてテーブルサイズを調整する再ハッシュの仕組みを追加したバージョン。
  * **HashTable\_4 (AVL tree)**: これはハッシュ値が衝突した場合の要素の保存方法として、連結リストの代わりにAVL木（自己平衡二分探索木）を使用したバージョン。
  * **HashTable\_5 (計画中)**: ハッシュテーブルにおいてハッシュ値が等しかった場合、要素の保存方法として二分木を使うバージョンとして実装予定（現時点では未作成）

-----

## 各バージョンの実行時間の比較と考察 (HashTable\_1 との比較)

各バージョンの実行時間を `hashtable_comparison.png` のグラフにまとめた。

### 1\. HashTable\_1 (Normal)

  * **内容**: 基本的なハッシュテーブルに `delete` 関数を追加。
  * **パフォーマンス**: グラフ（青線）では要素数が増えるにつれて実行時間が線形に増加している。これと他のバージョンとを比較する。要素数1000000の時点で実行時間は約107である。

-----

### 2\. HashTable\_2 (Change hash function)

  * **内容**: `calculate_hash` 関数を改善した。ASCIIコードの単なる和では、anagram同士などhash値が同じkeyが複数存在する可能性が高い。そのため、桁を1つずつずらしながら加算していきhash値を求める方法を使用した。桁を10ではなく素数にするとhash値が分散される傾向があるようだったので31とした。
  * **パフォーマンス**: グラフ（オレンジ線）では、HashTable\_1 に比べて実行時間が大幅に改善された。要素数500000付近では、HashTable\_1 の実行時間が約52であるのに対し、HashTable\_2 は約19.5である。
  計測中に画面がスリープするなどの事象が繰り返し起こったこと、処理に時間がかかることから要素数が540000個以降の正確なデータは取れていない。
  * **考察**:
      *  HashTable\_1 と比較して、約 $52 / 19.5 \\approx \\textbf{2.67倍高速}$ (要素数500000時点)。
      * ハッシュ関数を改善することで、ハッシュ値の衝突が減少し、結果として検索、挿入、削除の各操作における平均計算時間が短縮されたと考えられる。特に、衝突が減ることで連結リストが短くなり、その探索時間が削減された効果が大きいと考えられる。

-----

### 3\. HashTable\_3 (Rehash)

  * **処理内容**: 格納するアイテム数に合わせてバケットサイズを調整する再ハッシュ機能が追加した。バケットサイズには素数を用いる。バケットの使用率が70%以上になった場合、現在のサイズの約2倍の大きさに拡張する。バケットの使用率が30%以下になった場合、現在のサイズの約半分の大きさに縮小する。
  * **パフォーマンス**: Assertion Error（要素258個残存）が存在している状態で現在原因究明中なので、実行時間の結果も今後変化する可能性があります。
      * ほとんどの区間（特に要素数が少ない～中程度の範囲、および97付近まで）では、実行時間がほぼ0に近い。
      * 要素数98の点で実行時間が約3.23まで急上昇(スパイク)しています。
  * **考察**:
      * バグが修正された場合、要素数980000（HashTable\_1: 約106.7、HashTable\_3: 約0.038）で比較すると、約 $106.7 / 0.038 \\approx \\textbf{2800倍以上高速}$ である。これは負荷率が一定に保たれることで、各操作が平均的に $O(1)$ に近づくためであると考えられる。
      * 要素数990000での実行時間の急上昇は、大規模な再ハッシュ処理（テーブルの拡張と全要素の再配置）が発生したコストである可能性が高いと考えられる。バグがこの高負荷時に起こっている可能性も考えられる。

-----

### 4\. HashTable\_4 (AVL tree)

  * **処理内容**: ハッシュ衝突の解決ため、AVL木（自己平衡二分探索木）を使用しています。
  * **パフォーマンス**: グラフ（赤点線）では、全区間を通して実行時間が非常に短く、要素数1000000の時点で実行時間は約0.16である。
  * **考察**:
      * HashTable\_1 (実行時間約107) と比較して、約 $107 / 0.16 \\approx \\textbf{668倍高速}$ (要素数1000000時点)。
      * AVL木（自己平衡二分探索木）を衝突解決に使用すると、同一ハッシュ値に対する要素群の操作（検索、挿入、削除）が平均的にも最悪ケースでも $O(\\log k)$（kは衝突した要素数）で行うことが可能である。HashTable\_3 のようなバグや実行時間スパイクもなく、安定して高速なパフォーマンスが実現できた。

-----