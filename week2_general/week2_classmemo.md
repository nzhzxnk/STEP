## 授業メモ
* 測定ごとに結果もころころ変わる
* int a[N][N];　N*Nのメモリを使う 空間計算量 = O(N^2)
* for(i=0; i<N; i++) { // 時間計算量 = O(N^2)
* 計算量の小さいアルゴリズムを採用する！Nを予測できないことも多い
* Nが大きいと少しの高速化が重要になってくる
* NlogN,N**2
* バブルソート（N**2）の方が描きやすいとかね、普段はマージソートだけどバブルソートは小さい時有効
* 計算量の小さいアルゴリズム
* 通信とコードの高速化の関係：プログラムの外の要因でCPUが使われる
* 追加はN, どれを見つけて削除するかn
* 二分探索木　平均logn？（その前の奴らはほぼ誤差？）　最悪n
* なんでバランス崩れたら回転の頂点をJでとるのか、木の回転はなぜO(1)なのか　AVL木の回し方とか追加削除とか
* anagram2はa=2,b=3,c=5という感じで素数で定義して割り切れたら作れるねってする！！かしこすぎる！！
* ハッシュ値の衝突を減らすには K を素数にするとよい　これなぜ？？
* ハッシュ関数を2つ使う？と衝突が減る？
* 八種の衝突が増えたら、多段のハッシュテーブルを作る、再ハッシュで作り直す
* ハッシュの平均計算量はn/kだけど際ハッシュとかすることで0(1)にできる、最悪計算量はN
* ディスクスワップとは？
* desigin Documentで自分のコードをわかりやすくmarkdownできちんとかく！！
* なんで[このスライド](https://docs.google.com/presentation/d/1T8YYMqaf-LPgiIv75bG8r6HaP-WNC4dZgz3Las5TGD8/edit?slide=id.g23c41adceb3_0_14#slide=id.g23c41adceb3_0_14)のようになるのか：リハッシュするのに少し時間がかかるから
