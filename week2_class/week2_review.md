11の倍数はa-b+c-d
NlogNだとグラフの傾きは
SSD
HashTable3はrandomのミスによるもの、よく確認すること


31かけてくやつ、桁に応じて重みをつける。ローディングハッシュ法っていうらしい
木構造がいい理由
データ使用量に無駄がない
logNって意外と小さく、係数次第では
プレフィックス検索（ALYからはじまる）とか？しやすい

LRUアルゴリズム　きちんと理解して調べること
CPUのキャッシュに実際に使われている

暗号的ハッシュ関数
問題
テーブル攻撃などパスワード攻撃
ブルートフォース
よくあるパスワードからハッシュ値を計算できるのでバレる
対策
ソルト化
元の文字列に乱数を加えて複合したのちにハッシュ値を計算

トライ木
多分木でデータを保存する。
実装は激ムズ、効率よく作るのが非常に難しい
O(1)だけど定数係数が大きい

ハッシュ関数
なぜ攻撃が起こる？？

## 計算量
* 測定ごとに結果もころころ変わる
* int a[N][N];　N*Nのメモリを使う 空間計算量 = O(N^2)
* for(i=0; i<N; i++) { // 時間計算量 = O(N^2)
* 計算量の小さいアルゴリズムを採用する！Nを予測できないことも多い
* Nが大きいと少しの高速化が重要になってくる
* NlogN,N**2
* バブルソート（N**2）の方が描きやすいとかね
* 計算量の小さいアルゴリズム
* 空間計算量
* 通信とコードの高速化の関係
* プログラムの外の要因でCPUが使われる
* 追加はN, どれを見つけて削除するかn
* 連結リストってなんでつかうんだ？効率悪そうだけど
* 二分探索木　平均logn？（その前の奴らはほぼ誤差？）　最悪n
* なんでバランス崩れたら回転の頂点をJでとるのか、木の回転はなぜO(1)なのか
* 木の追加削除はどうやってするのか
* anagram2はa=2,b=3,c=5という感じで素数で定義して割り切れたら作れるねってする
* ハッシュ値の衝突を減らすには K を素数にするとよい　これなぜ？？
* ハッシュ関数を2つ使う？と衝突が減る？
* 八種の衝突が増えたら、多段のハッシュテーブルを作る、再ハッシュで作り直す
* ハッシュの平均計算量はn/kだけど際ハッシュとかすることで0(1)にできる、最悪計算量はN
* Pythonの辞書を実装してみる！一旦元のコードを使ってみる
* 元のコードを理解する
* 木構造の方が好まれる理由を4,5個
* ディスクスワップとは？
* desigin Documentで自分のコードをわかりやすくmarkdownできちんとかく！！
* なんで[このスライド](https://docs.google.com/presentation/d/1T8YYMqaf-LPgiIv75bG8r6HaP-WNC4dZgz3Las5TGD8/edit?slide=id.g23c41adceb3_0_14#slide=id.g23c41adceb3_0_14)のようになるのか