## コーディングテストについて
* 技術的な議論
* どう考えて答えに到達するか、それをいかに伝えられるか
* コードによるコミュニケーション
* より良いエンジニア
* STEPで学んだことをより一層深く身につける(week1-4で学んだこと)
* コーディングボードではコード実行できない
* 方針メモなど自由に書いていい
* Editorなしで練習する、紙に書く、ドキュメントにどうやって書くかを練習して決めよう！！
* 長いコードは書かない、1,2問
* パターン化する、事前に流れのパターンを作っておく！！
* 方針、実装、テストに分けて練習する hiromさんのスライド参考に
* 入出力例（とその型）を書く。入出力例与えられないことも多い。問題の理解ミスを防ぐ。
* leetcodeでも入出力名見ないでやってみる。
* 前提条件がわからない場合は面接官に聞く！むしろそれが求められている。
* 色々曖昧な問題に対応する。
* 数の扱い、エッジケースについて理解を深める。
* 考えなければならない前提条件などその優先順位について理解する。
* 複数思いついてるなら相談してもいい
* 頭真っ白になったら、入出力例を考えてみたり、問題を細分化して小さい問題にする
* 何も書かないよりはまし
* いきなりコード書かない！！！全然聞いていいからコミュニケーションとる。
* 方針について説明して確認を取る。
* 声に出してコード書く。自分が何してるかを説明する。
* 部分的に書き方わからない時は、これやりたいんですけど忘れちゃいましたって言って仮置きする。
* テストケースを作っておくから大事
* コードを見直し、デバックする時間もとても大事
* エッジケースにも対応
* 1行ずつデバックして時間計算量と空間計算量を両方計算する。
* 改善できるところありますか？って聞かれたら改善する。言われなかったら進む可能性もある。
* 関数の入力と出力の型が何か確認する。
* わからないならきちんと聞く！何がわからないか適切にヘルプを求める！！
* ライブラリの関数使うなら計算量知っておかなきゃだけど、そんな問題は出ない
* コード書く手順

### コードの評価ポイントとは？
* モジュール化された綺麗なコードが書けること
* コメント等を使って設計思想を伝えること
* 時間内になるべく速く仕上げること
* 時間的計算量・空間的計算量を考え、その問題の状況に合わせて優先して最小限にすべきものを考える。
* バグが出てもでバッキングなどをきちんと行うこと

### 試験の形式は？
* 文章や口頭で説明するのか。
* コメントだけなのか
* 説明しながらコード書くのか
* 書き終わった後に説明するのか
* 設計思想、コードの説明、工夫した内容、問題点など？
* どのくらいの時間で喋る？どのくらいの準備時間がある？
### コーディング試験で見ていることとは？

### 授業メモ
* 変に向きがあることを有向
* 連結グラフ（無向）、強連結グラフ（有向）、すべての任意の二点間にパスが存在する
* 連結、閉路がなく、重みなし、無向
* レンダリング？
* 日常においてグラフに落とし込めるか
* 連想配列　連結リスト、前を保存しておく
* 配列を組む　現実世界では疎なグラフが空間計算量が問題になる
* 隣接グラフ　うちらが考えてたやつ
* 深さ優先探索いけなくなったら終了　[BFS/DFS](https://docs.google.com/presentation/d/1m6uTcNhnmjky578GVXMbyOCu2-yM4lNqU8FR5eJdx_I/edit?slide=id.g1e13c1d4e24_1_220#slide=id.g1e13c1d4e24_1_220)
* edgeを使ったかどうかを保存しておき、もう一回通ったらループしてると判定。setでもいいし、boolのリストを作ってもいい
* 最短経路はBPS
* 検索はDFSしてるんだね
* グラフの順番つける練習してみて！
* Aから深さ優先探索してるのか、Gからたどれるノードをすべてたどる　→　Eからたどれるノードをすべてたどる　→　Bからたどれるノードをすべてたどるという意味で深さ優先
* DFSの方法は一つじゃない！！
* nodeを辿る順序が変わるだけ、DFSは深く深くというだけで順番などがきまっていないから　[](https://docs.google.com/presentation/d/1m6uTcNhnmjky578GVXMbyOCu2-yM4lNqU8FR5eJdx_I/edit?slide=id.g24e5a167191_0_3#slide=id.g24e5a167191_0_3)
* 時間計算量O(N+E)とする説もあるが、E本のedgeで辿れるノードは最大EだからO(E)があってる
* 手法や順書が違うだけで、探索中のノードから未選択のノードを見つけていく。DFSBFSはやってることは同じ。
* DFS：スタック、再帰（スタックと再帰の関連）、BFS:キュー
* Pagerank　フロベニウスの定理を使う時に行列の要素が正の数じゃないといけない
* largeは6GBのメモリ必要
* [データセットの説明](https://docs.google.com/presentation/d/1m6uTcNhnmjky578GVXMbyOCu2-yM4lNqU8FR5eJdx_I/edit?slide=id.g1e13c1d4e24_1_507#slide=id.g1e13c1d4e24_1_507)
* NP困難とは
* フラグを立てる場所や、Pの選び方によって経路が変わる　詳しくはhomework summaryをみて。

