大きさに合わせて2optの方法を変える
greedyの後に2opt
焼きなまし、反復的局所最適？、局所最適解

ゼロからできるOS自作入門
LinuxKernel
セキュリティー向上
作って学ぶOSの仕組み Hikaliumさん
ブラウザの仕組み Asamiさん

プログラムが動く仕組みをきちんと知る
順番、手順
インタープリター　実行時にソースコードを1行ずつ解釈し機械語にして実行する
コンパイラ言語　実行の前にコンパイルして事前にbinaryにしている、その後実行。だから早い

コンパイらは繰り返しの処理とかよく行う時に力を発揮、インタプリタは実行時の情報をリアルタイムに得られるところがいい
適材適所

ソースコード プログラミング言語で書かれたプログラミング
自然言語
* ビット 電圧の高い低い(0/1)
* 16 = 2^4 なので、2進法の4桁と16進法の1桁が対応するので、2進数の性質を持ったまま短くできる
* 画像でもプログラムでもなんでもbinaryで表される
* いろいろなデータをバイナリーデータにしてみる `hexdump -C <file_name>`
* エンコーディング　文字から文字コードへの対応、漢字などに対応するためUTF8
* CPUへの話は来週
* コンパイラ　ソースコード（人間の読めるプログラミング）から機械語に
* プログラムの最適化とは　高速化、小さい、言語やアルゴリズム選択のタイミング
* プログラムが小さいとなにがいいのか　大きさとダウンロード時間、がゆえのダウンロード数

メモリの読み書き
レジスタ　記憶領域64bit*数十個　1kb
写真 200mb
addr どこの記憶
mode W or R
data データの中身
C言語とか特に　配列＝メモリ
アドレス　1バイトごとについた連番
計算量上はO(1)の操作　addrやメモリの読み書きの時間はほぼ考えなくていいものとする

ライブラリとOS
ソフトフェア

1. printf()	ライブラリの関数、ライブラリが面倒見るとはどういうこと？
2. 画面に文字を表示する　OS InputとOutputの担当　指示はアプリケーション、実際させたのはOS
3. 画面に画像を表示する　圧縮を外すのはライブラリも担当している
4. 行列積を計算する　ライブラリ、アプリケーションが独自に実装している　計算しているのはハードウェア
5. ファイルをHDD/SSDに保存する　外部のデバイスと橋渡しする　ウィンドウに表示するのもOS
6. メモリにデータを書き込む　管理はOS、アプリケーションのコードはメモリにはアクセスできる、CPUから直接アクセスできる
7. アプリからアクセスできるメモリを用意する　これは？？
8. ネットワーク経由でデータを送信する
ネットワークスタック？OSライブラリ　外部のハードウェアを制御してできること、アプリケーションやライブラリにネットワークのレイヤーが移りつつある、高速パフォーマンスDPTK
OSはあまりたくさん修正したくないので
9. malloc() / free()　ライブラリが提供している、OSに頼んではいる
CPUやめもりはハードウェア？

C言語ないのメモリの最適化
コンパイル時にエラーにならない

 undefined behavior (未定義動作) は何が起きてもおかしくない
 なんで

gcc test.c ./a.out
gcc -o3 test.c　最適化あり？なし？
gcc fe=zalize　?　みたいなやつで実行時エラーを生むこともできる
C言語だと配列はただのアドレス計算+メモリアクセスなので
配列の範囲外にアクセスして他の配列を壊すことができる
 segmentation faultは	OSが許可していないメモリ領域をアプリが勝手に使おうとしたらOSがアプリを止める、ちょっとだったらバレない可能性もある、、

malloc(size) 
整数 size が渡される 
まだ貸し出していないメモリから
少なくともsizeバイト連続している領域を見つけて
アプリに貸し出す（allocate）
貸し出した領域のアドレスをアプリに返す

free(addr)
メモリアドレスを表す整数addrが渡される
もう使わなくなったaddrから始まる領域をアプリから返してもらう
返すアドレスは自由！状況によって異なる
OSがmallocに使っていい領域を決めてる（reserved以外のavailable）

メモリリーク
いらなくなったものは返す！エラーとかは怒らないけどいつかOSに怒られる

mallocもfreeも、メモリの利用状況の情報が必要
どのアドレス範囲が空いているか
どのアドレス範囲が使われているか

OSからmallocへのインターフェイス
void *mmap_from_system(size_t size);
sizeは「OSからもらいたい領域の大きさ」
OSはメモリ領域を確保して、その開始アドレスを返す
void munmap_to_system(void *ptr, size_t size);
ptrは「OSに返したい領域の開始アドレス」
sizeは「OSに返したい領域の大きさ」
ptr番地からsizeバイト分の領域をOSに返却する
* ptrとsizeは4096の倍数（ページ単位の操作になるため）
mallocが使える外部の関数はこれだけ！
Free List: メモリの利用状況を保持するデータ構造

めたでーたって何
Linkedlist
C言語で配列の添字アクセスとポインタへの加減算は等価
"*(((simple_metadata_t *) p) - 1)" は "((simple_metadata_t *) p)[-1]" と同じ
リストの範囲外インデックスを裏返しに利用する


First Fit / Best Fit / Worst Fitを実装してみる、どこのメタデータから

1000以下は10分割にして、それ以上は4分割の合計14個のbinに振り分けるなど、分割幅を変えるのもいいかも


my_heap_tのdummyは
リストの終わりを示すために使われているけれど
my_heap_tごとに存在する必要はあるかな？
→ なさそう（理由は…回答お待ちしています！

merge左は簡単
右左どっちも
絵を描きながら
freelist bin + 空き領域のmergeをしても思ったより性能が上がらないことも…なぜか考える