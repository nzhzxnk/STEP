## 計算量
* 測定ごとに結果もころころ変わる
* int a[N][N];　N*Nのメモリを使う 空間計算量 = O(N^2)
* for(i=0; i<N; i++) { // 時間計算量 = O(N^2)
* 計算量の小さいアルゴリズムを採用する！Nを予測できないことも多い
* Nが大きいと少しの高速化が重要になってくる
* NlogN,N**2
* バブルソート（N**2）の方が描きやすいとかね
* 計算量の小さいアルゴリズム
* 空間計算量
* 通信とコードの高速化の関係
* プログラムの外の要因でCPUが使われる
* 追加はN, どれを見つけて削除するかn
* 連結リストってなんでつかうんだ？効率悪そうだけど
* 二分探索木　平均logn？（その前の奴らはほぼ誤差？）　最悪n
* なんでバランス崩れたら回転の頂点をJでとるのか、木の回転はなぜO(1)なのか
* 木の追加削除はどうやってするのか
* anagram2はa=2,b=3,c=5という感じで素数で定義して割り切れたら作れるねってする
* ハッシュ値の衝突を減らすには K を素数にするとよい　これなぜ？？
* ハッシュ関数を2つ使う？と衝突が減る？
* 八種の衝突が増えたら、多段のハッシュテーブルを作る、再ハッシュで作り直す
* ハッシュの平均計算量はn/kだけど際ハッシュとかすることで0(1)にできる、最悪計算量はN
* Pythonの辞書を実装してみる！一旦元のコードを使ってみる
* 元のコードを理解する
* 木構造の方が好まれる理由を4,5個
* ディスクスワップとは？
* desigin Documentdで自分のコードをわかりやすくmarkdownできちんとかく！！
